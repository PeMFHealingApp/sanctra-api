<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex,nofollow" />
  <title>Sanctra IR</title>

  <!-- Quicksand -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;600;700&display=swap" rel="stylesheet">

  <!-- Favicons -->
  <link rel="icon" href="./faviconV2.jpeg?v=2" type="image/jpeg">
  <link rel="apple-touch-icon" href="./faviconV2.jpeg?v=2" sizes="180x180">
  <link rel="icon" href="./favicon.ico?v=2" type="image/x-icon" sizes="any">

  <meta name="theme-color" content="#0b0b0b" />

  <!-- Your separated CSS file (unchanged) -->
  <link rel="stylesheet" href="style.css?v=2025-09-07-8" />
</head>

<body>
  <div id="root"></div>

  <!-- React -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>

  <script>
  const { useEffect, useRef, useState } = React;

  // ---------------- CONFIG ----------------
  const apiOverride = new URLSearchParams(location.search).get("api");
  const API_BASE = (apiOverride && /^https?:\/\//.test(apiOverride))
    ? apiOverride.replace(/\/+$/, "")
    : "https://sanctra-api.onrender.com";

  const ENDPOINTS = {
    countries: API_BASE + "/countries",
    sitesForCountry: c => API_BASE + "/sites-for-country?country=" + encodeURIComponent(c),
    siteInfo: s => API_BASE + "/site-info?site=" + encodeURIComponent(s),
    siteImage: s => API_BASE + "/site-image?site=" + encodeURIComponent(s),
    genIR: API_BASE + "/generate-ir"
  };

  // ---------------- UTIL ----------------
  async function safeJSON(res){
    try { return await res.json(); }
    catch { try { return await res.text(); } catch { return null; } }
  }
  const clamp01 = v => Math.max(0, Math.min(1, Number(v)));
  const pad = n => n<10 ? "0"+n : ""+n;
  const fmtTime = s => { s = Math.max(0, Math.floor(s)); const m = Math.floor(s/60), r = s%60; return m+":"+pad(r); };

  const toArray = (data, keys=[]) => {
    if (Array.isArray(data)) return data;
    if (data && typeof data === "object") {
      for (const k of keys) if (Array.isArray(data[k])) return data[k];
      const any = Object.values(data).find(v => Array.isArray(v));
      if (any) return any;
    }
    if (typeof data === "string") {
      const parts = data.split(/[\n,]+/).map(s=>s.trim()).filter(Boolean);
      if (parts.length) return parts;
    }
    return [];
  };

  const normalizeCountries = raw =>
    toArray(raw, ["countries","items","data","list"])
      .map(x => typeof x === "string" ? x : (x?.name || x?.title || x?.country || ""))
      .filter(Boolean);

  const normalizeSites = raw =>
    toArray(raw, ["sites","items","data","list"])
      .map(x => typeof x === "string" ? x : (x?.name || x?.title || x?.site || ""))
      .filter(Boolean);

  const normalizeImage = raw => {
    if (!raw) return "";
    if (typeof raw === "string") return raw.startsWith("http:") && location.protocol==="https:" ? "https:" + raw.slice(5) : raw;
    if (Array.isArray(raw)) return normalizeImage(raw[0]);
    const c = raw.image_url || raw.url || raw.src || raw.href || raw.image || raw.result?.url || raw.data?.url || "";
    if (!c) return "";
    return c.startsWith("http:") && location.protocol==="https:" ? "https:" + c.slice(5) : c;
  };

  function pickByRegex(obj, re){
    for (const [k,v] of Object.entries(obj||{})){
      if (re.test(k) && typeof v === "string" && v.trim()) return v;
    }
    return "";
  }
  const normalizeInfo = raw => {
    const d = raw?.info && typeof raw.info === "object" ? raw.info : (raw || {});
    const desc = d.description || d.text || pickByRegex(d, /(overview|about|description)/i);
    const why = d.why_sacred || d.why || d.why_is_this_sacred || d.why_this_is_sacred || pickByRegex(d, /(why).*sacred/i);
    const who = d.who_is_this_for || d.who || d.audience || d.target_audience || d.for_whom || pickByRegex(d, /(who).*for|audience/i);
    const benefits = d.health_benefits || d.benefits || pickByRegex(d, /(benefit)/i);
    return {
      region: d.region || "",
      description: desc || "",
      why_sacred: why || "",
      health_benefits: benefits || "",
      who_is_this_for: who || "",
      disclaimer: d.disclaimer || ""
    };
  };

  // ---------------- CUSTOM DROPDOWN ----------------
  function Dropdown({ value, options, onChange, busy }) {
    const [open, setOpen] = useState(false);
    const ref = useRef(null);
    useEffect(()=>{
      const onDoc = e => { if (!ref.current) return; if (!ref.current.contains(e.target)) setOpen(false); };
      document.addEventListener("click", onDoc);
      return () => document.removeEventListener("click", onDoc);
    },[]);
    return (
      React.createElement("div", { className:"dd", ref },
        React.createElement("button", { className:"ddBtn", onClick:()=>setOpen(o=>!o), "aria-expanded":open, "aria-haspopup":"listbox" },
          React.createElement("span", { className:"ddValue" }, value || "—"),
          React.createElement("span", { className:"arrow" })
        ),
        open && React.createElement("div", { className:"ddList", role:"listbox" },
          busy ? React.createElement("div", { className:"ddLoading" }, React.createElement("div",{className:"spinner"}), "Loading…")
               : options.map(opt =>
                  React.createElement("div", {
                    key:String(opt),
                    role:"option",
                    "aria-selected": String(opt)===String(value),
                    className:"ddItem"+(String(opt)===String(value)?" sel":""),
                    onClick:()=>{ onChange(String(opt)); setOpen(false); }
                  }, String(opt))
                )
        )
      )
    );
  }

  // ---------------- AUDIO ENGINE ----------------
  class IREngine {
    constructor(){
      this.context = null;
      this.master = null;
      this.limiter = null;
      this.nodes = null;
      this.loop = false;
      this.startedAt = 0;
      this.onUpdate = () => {};
      this._raf = null;
      this.defaultProgram = { base_hz:200, binaural_split_hz:4, isotonic_rate_hz:0.25, pink_noise_gain:0.06 };

      // iOS background pipe + IR variants for low-power mode
      this.pipeDest = null;
      this.pipeEl = null;
      this._fullIR = null;
      this._shortIR = null;
    }
    async ensure(){
      if (!this.context){
        const AC = window.AudioContext || window.webkitAudioContext;
        this.context = new AC({ latencyHint:"playback" });
        // Master gain into limiter into destination
        this.master = this.context.createGain();
        const ceiling = 0.89125; // -1 dB linear
        this.master.gain.value = ceiling;

        const comp = this.context.createDynamicsCompressor();
        comp.threshold.value = -3;
        comp.knee.value = 0.1;
        comp.ratio.value = 20;
        comp.attack.value = 0.002;
        comp.release.value = 0.10;
        this.limiter = comp;

        this.master.connect(this.limiter).connect(this.context.destination);

        // Keep alive on focus
        document.addEventListener("visibilitychange", () => {
          if (document.visibilityState === "visible" && this.context.state !== "running") this.context.resume();
        }, { passive:true });

        // Stop on leave
        window.addEventListener("pagehide", ()=>this.stop(), { passive:true });
        window.addEventListener("beforeunload", ()=>this.stop(), { passive:true });
      }
      if (this.context.state === "suspended") await this.context.resume();
    }

    // iOS background pipe using a silent local asset
    async attachPipe(){
      await this.ensure();
      if (this.pipeDest) return;

      let el = document.getElementById("bg-silence");
      if (!el) {
        el = document.createElement("audio");
        el.id = "bg-silence";
        el.src = "./silence.mp3"; // place in /docs
        el.loop = true;
        el.preload = "auto";
        el.setAttribute("playsinline", "");
        el.setAttribute("webkit-playsinline", "");
        el.crossOrigin = "anonymous";
        el.style.display = "none";
        document.body.appendChild(el);
      }
      this.pipeEl = el;
      try {
        // very low volume so the pipeline stays active
        el.volume = 0.001;
        await el.play();
      } catch(e) {
        // if user gesture required, play() will succeed when called from the gesture handler
      }
      try {
        const src = this.context.createMediaElementSource(el);
        src.connect(this.master);
        this.pipeDest = src;
      } catch(e) {
        // MediaElementSource can be created only once per element; ignore if already connected
      }
    }

    setVolume(v){
      if (this.master) this.master.gain.setTargetAtTime(0.89125 * clamp01(v), this.context.currentTime, 0.01);
    }
    stop(){
      if (this.nodes){
        const { oscL, oscR, mod, noiseSrc, modalBank } = this.nodes;
        [oscL,oscR,mod,noiseSrc].forEach(n=>{ try{ n && n.stop(); }catch{} });
        modalBank && modalBank.forEach(m=>{ try{ m.src.stop(); }catch{} });
      }
      this.nodes = null;
      cancelAnimationFrame(this._raf); this._raf=null;
    }
    _num(o, keys, d=0){ for (const k of keys){ if (o && o[k]!=null && isFinite(o[k])) return Number(o[k]); } return d; }

    async buildIRBuffer(irJson){
      await this.ensure();
      const ctx = this.context, sr = ctx.sampleRate;
      const taps = Array.isArray(irJson?.early_reflection_taps) ? irJson.early_reflection_taps
                  : Array.isArray(irJson?.taps) ? irJson.taps : [];
      const modes = Array.isArray(irJson?.modal_summary) ? irJson.modal_summary
                  : Array.isArray(irJson?.modes) ? irJson.modes : [];
      const bands = Array.isArray(irJson?.rt60_s_by_band) ? irJson.rt60_s_by_band
                  : Array.isArray(irJson?.rt60Bands) ? irJson.rt60Bands : [];

      const preDelay = this._num(irJson, ["pre_delay_s","predelay_s","pre_delay","preDelay"], 0);
      const stereoWidth = clamp01(this._num(irJson, ["stereo_width","width","stereo"], 0.7));
      const earlyLateBalance = clamp01(this._num(irJson, ["early_late_balance","mix","wet"], 0.6));
      const hfRolloffHz = Math.max(0, this._num(irJson, ["hf_rolloff_hz","hf_rolloff"], 0));
      const lfeGain = clamp01(this._num(irJson, ["lfe_gain","lfe"], 0));

      const lastTap = taps.reduce((m,t)=>Math.max(m, this._num(t,["time_s","t","delay_s","time"],0)), 0);
      const maxRT = bands.reduce((m,b)=>Math.max(m, this._num(b,["rt60_s","rt60","decay_s"],0)), 0) || 2.5;

      const irLenSec = Math.min(14, Math.max(3, preDelay + lastTap + 1.9*maxRT));
      const len = Math.floor(sr * irLenSec);
      const buf = ctx.createBuffer(2, len, sr);
      const L = buf.getChannelData(0), R = buf.getChannelData(1);
      const preN = Math.floor(preDelay * sr);

      // Early reflections
      const earlyScale = 1 - earlyLateBalance;
      taps.forEach(t=>{
        const tSec = this._num(t,["time_s","t","delay_s","time"],0);
        const n = Math.min(len-1, Math.max(0, preN + Math.floor(tSec*sr)));
        const g = this._num(t,["gain","g","amp","a"], 0.7) * earlyScale;
        const pan = this._num(t,["pan","p"], (Math.random()*2-1)*stereoWidth);
        const wl = clamp01(0.5 - pan/2), wr = clamp01(0.5 + pan/2);
        for (let k=-2;k<=2;k++){
          const i = Math.max(0, Math.min(len-1, n+k));
          const w = 1 - Math.abs(k)/3;
          L[i] += g * wl * w;
          R[i] += g * wr * w;
        }
      });

      // Helpers
      const nearestRT = f=>{
        if (!bands.length) return maxRT;
        let best = bands[0], bd = Math.abs(f - (best.center_hz || best.freq_hz || best.hz || 500));
        for (let i=1;i<bands.length;i++){
          const fi = bands[i].center_hz || bands[i].freq_hz || bands[i].hz || 500;
          const di = Math.abs(f - fi);
          if (di < bd){ bd=di; best=bands[i]; }
        }
        return Math.max(0.25, best.rt60_s || best.rt60 || best.decay_s || maxRT);
      };
      const lambda = rt => Math.log(0.001) / Math.max(1, rt * sr);
      const itdl = Math.floor(0.0006 * sr) * stereoWidth;
      const lpAlpha = hfRolloffHz > 0 ? Math.exp(-(Math.PI*2) * hfRolloffHz / sr) : 0;

      // Late modal tail
      modes.slice(0,256).forEach(m=>{
        const f = Math.max(25, Number(m.freq_hz ?? m.f ?? m.freq ?? 0));
        if (!isFinite(f) || f<=0) return;
        const g0 = Number(m.gain ?? m.g ?? m.amp ?? m.a ?? 0.4) * earlyLateBalance;
        const rt = nearestRT(f);
        const lam = lambda(rt);
        const w = (Math.PI*2) * f / sr;
        const ph = Math.random() * Math.PI*2;
        let yl=0, yr=0;
        for (let n=0;n<len;n++){
          const env = Math.exp(n * lam);
          let s = env * Math.sin(w*n + ph) * g0;
          if (hfRolloffHz>0){ yl = lpAlpha*yl + (1-lpAlpha)*s; yr = lpAlpha*yr + (1-lpAlpha)*s; } else { yl=s; yr=s; }
          const li = n, ri = Math.min(len-1, n + itdl | 0);
          L[li] += yl; R[ri] += yr;
        }
      });

      // LFE bloom
      if (lfeGain>0){
        let al=0, ar=0; const k = 0.0005 * lfeGain;
        for (let n=0;n<len;n++){
          al = (1-k)*al + k*L[n]; ar = (1-k)*ar + k*R[n];
          L[n] += al * 0.25 * lfeGain; R[n] += ar * 0.25 * lfeGain;
        }
      }

      // Fade & normalize with headroom
      const fade = Math.min(Math.floor(len*0.12), Math.floor(sr*0.8));
      let peak = 0;
      for (let n=0;n<len;n++){
        if (n > len - fade){ const t = (n - (len - fade)) / fade; const w = 1 - t; L[n]*=w; R[n]*=w; }
        peak = Math.max(peak, Math.abs(L[n]), Math.abs(R[n]));
      }
      const norm = peak>0 ? Math.min(0.88/peak, 2.0) : 1;
      for (let n=0;n<len;n++){ L[n]*=norm; R[n]*=norm; }
      return buf;
    }

    makePink(ctx, seconds){
      const len = Math.max(1, Math.floor(ctx.sampleRate * seconds));
      const b = ctx.createBuffer(2, len, ctx.sampleRate);
      for (let ch=0; ch<2; ch++){
        const d = b.getChannelData(ch);
        let b0=0,b1=0,b2=0;
        for (let i=0;i<len;i++){
          const w = Math.random()*2-1;
          b0 = 0.997*b0 + 0.003*w;
          b1 = 0.985*b1 + 0.015*w;
          b2 = 0.95*b2 + 0.05*w;
          d[i] = (b0+b1+b2)/3;
        }
      }
      return b;
    }

    createProgramNodes(irBuffer, hints={}, irJson={}){
      const ctx = this.context;
      const program = {
        base_hz: hints.base_hz ?? irJson?.program?.base_hz ?? this.defaultProgram.base_hz,
        binaural_split_hz: hints.binaural_split_hz ?? irJson?.program?.binaural_split_hz ?? this.defaultProgram.binaural_split_hz,
        isotonic_rate_hz: hints.isotonic_rate_hz ?? irJson?.program?.isotonic_rate_hz ?? this.defaultProgram.isotonic_rate_hz,
        pink_noise_gain: hints.pink_noise_gain ?? irJson?.program?.pink_noise_gain ?? this.defaultProgram.pink_noise_gain
      };

      const merger = ctx.createChannelMerger(2);
      const convolver = ctx.createConvolver(); 
      convolver.normalize = true; 
      convolver.buffer = irBuffer;
      // remember full IR
      this._fullIR = irBuffer;
      this._shortIR = null;

      const wet = ctx.createGain(); wet.gain.value = 1.0;
      const dry = ctx.createGain(); dry.gain.value = 0.0;

      const oscL = ctx.createOscillator(), oscR = ctx.createOscillator();
      oscL.type = "sine"; oscR.type = "sine";
      const base = Math.max(20, program.base_hz);
      const split = Math.max(0, program.binaural_split_hz);
      oscL.frequency.value = base - split/2; oscR.frequency.value = base + split/2;

      const mod = ctx.createOscillator(); mod.type = "sine"; mod.frequency.value = Math.max(0.05, program.isotonic_rate_hz);
      const modGL = ctx.createGain(); modGL.gain.value = 0.33;
      const modGR = ctx.createGain(); modGR.gain.value = 0.33;
      const ampL = ctx.createGain(); ampL.gain.value = 0.45;
      const ampR = ctx.createGain(); ampR.gain.value = 0.45;
      mod.connect(modGL); mod.connect(modGR); modGL.connect(ampL.gain); modGR.connect(ampR.gain);
      oscL.connect(ampL); oscR.connect(ampR);

      const noise = this.makePink(ctx, 4.0);
      const noiseSrc = ctx.createBufferSource(); noiseSrc.buffer = noise; noiseSrc.loop = true;
      const nGain = ctx.createGain(); nGain.gain.value = Math.max(0, program.pink_noise_gain);
      noiseSrc.connect(nGain).connect(merger);

      // Modal sparkles
      const modal = [];
      const modes = Array.isArray(irJson?.modal_summary) ? irJson.modal_summary : [];
      modes.slice(0,48).forEach((m,i)=>{
        const f = Math.max(30, Number(m.freq_hz ?? m.f ?? m.freq ?? 0));
        if (!isFinite(f) || f<=0) return;
        const g = Number(m.gain ?? m.g ?? m.amp ?? m.a ?? 0.15);
        const src = ctx.createOscillator(); src.type = "sine"; src.frequency.value = f;
        const gn = ctx.createGain(); gn.gain.value = 0.10 * g;
        gn._baseGain = g; // store base
        src.connect(gn).connect(merger, 0, i%2);
        modal.push({src, gn});
      });

      ampL.connect(merger, 0, 0); ampR.connect(merger, 0, 1);
      merger.connect(convolver);
      convolver.connect(wet).connect(this.master);
      merger.connect(dry).connect(this.master);

      this.nodes = { oscL, oscR, mod, ampL, ampR, noiseSrc, modalBank: modal, wet, dry, convolver };
    }

    async loadAndStart(irJson, hints={}){
      await this.ensure();
      const irBuffer = await this.buildIRBuffer(irJson);
      this.createProgramNodes(irBuffer, hints, irJson);
      const { oscL, oscR, mod, noiseSrc, modalBank } = this.nodes;
      noiseSrc.start(); modalBank.forEach(m=>m.src.start());
      oscL.start(); oscR.start(); mod.start();
      this.startedAt = this.context.currentTime;
      const tick = () => { this.onUpdate(); this._raf = requestAnimationFrame(tick); };
      this._raf = requestAnimationFrame(tick);
    }

    // Reduce CPU when hidden, restore when visible
    enterLowPower(quiet){
      if (!this.nodes || !this.context) return;
      const { convolver, modalBank } = this.nodes;
      const now = this.context.currentTime;

      // Trim IR for background
      if (quiet) {
        if (convolver && convolver.buffer && !this._shortIR && this._fullIR) {
          const b = this._fullIR, sr = b.sampleRate;
          const sec = Math.min(3, b.length / sr);
          const frames = Math.max(1, Math.floor(sec * sr));
          const short = this.context.createBuffer(2, frames, sr);
          for (let ch=0; ch<Math.min(2,b.numberOfChannels); ch++) {
            short.getChannelData(ch).set(b.getChannelData(ch).subarray(0, frames));
          }
          this._shortIR = short;
        }
        if (convolver && this._shortIR) convolver.buffer = this._shortIR;
      } else {
        if (convolver && this._fullIR) convolver.buffer = this._fullIR;
      }

      // Reduce modal load in background
      if (modalBank && modalBank.length){
        const keep = quiet ? 8 : 48;
        modalBank.forEach((m,i)=>{
          const target = (i < keep) ? (quiet ? 0.06 : 0.10) * (m._baseGain || 1) : 0;
          m.gn.gain.setTargetAtTime(target, now, 0.08);
        });
      }
    }
  }

  // ---------------- APP ----------------
  function App(){
    const [booting, setBooting] = useState(true);
    const [countries, setCountries] = useState([]);
    const [allSites, setAllSites] = useState([]);
    const [country, setCountry] = useState("Egypt");
    const [sites, setSites] = useState([]);
    const [site, setSite] = useState("");
    const [info, setInfo] = useState(null);
    const [img, setImg] = useState("");
    const [imgBroken, setImgBroken] = useState(false);
    const [minutes, setMinutes] = useState(15);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState("");

    const [playerOpen, setPlayerOpen] = useState(false);
    const [isPlaying, setIsPlaying] = useState(false);
    const [loop, setLoop] = useState(false);
    const [volume, setVolume] = useState(0.85);
    const [currentTime, setCurrentTime] = useState(0);

    const totalTime = minutes * 60;
    const irRef = useRef(null);

    function stopOtherAppAudio(){ try{ window.parent.postMessage({ type:"pemf_stop_all_audio" }, "*"); }catch{} }
    useEffect(()=>{ stopOtherAppAudio(); },[]);

    // Initial load
    useEffect(()=>{
      let alive = true;
      const init = async ()=>{
        try{
          setLoading(true);
          const cRes = await fetch(ENDPOINTS.countries);
          const cRaw = await safeJSON(cRes);
          let list = normalizeCountries(cRaw);
          if (!list.includes("Egypt")) list = ["Egypt", ...list.filter(x=>x!=="Egypt")];

          const siteLists = await Promise.all(list.map(async c=>{
            try{
              const r = await fetch(ENDPOINTS.sitesForCountry(c));
              const j = await safeJSON(r);
              return normalizeSites(j);
            } catch { return []; }
          }));
          const agg = [...new Set(siteLists.flat())].sort((a,b)=>a.localeCompare(b));
          if (!alive) return;
          setCountries(["All Sites", ...list]);
          setAllSites(agg);

          const egRes = await fetch(ENDPOINTS.sitesForCountry("Egypt"));
          const egRaw = await safeJSON(egRes);
          const egList = normalizeSites(egRaw);
          const preferred = egList.find(s=>/king'?s?\s+chamber/i.test(s)) || egList[0] || "";
          setSites(egList); setSite(preferred);
        } catch(e){ console.error(e); if (alive) setError("Unable to load initial data."); }
        finally { if (alive){ setLoading(false); setTimeout(()=>setBooting(false), 300); } }
      };
      init();
      return ()=>{ alive=false; stopAll(true); };
    },[]);

    // Update on country change
    useEffect(()=>{
      let alive=true;
      const run = async ()=>{
        try{
          setLoading(true); setError(""); setImgBroken(false);
          if (country==="All Sites"){
            setSites(allSites); setSite(allSites[0] || "");
          } else {
            const r = await fetch(ENDPOINTS.sitesForCountry(country));
            const j = await safeJSON(r);
            const sl = normalizeSites(j);
            setSites(sl); setSite(sl[0] || "");
          }
        } catch(e){ console.error(e); if (alive) setError("Failed to load sites."); }
        finally{ if (alive) setLoading(false); }
      };
      if (allSites.length || country!=="All Sites") run();
      return ()=>{ alive=false; };
    }, [country, allSites]);

    // Stop audio when preset changes
    useEffect(()=>{ if (isPlaying) stopAll(false); }, [country]);
    useEffect(()=>{ if (isPlaying) stopAll(false); }, [site]);
    useEffect(()=>{ if (isPlaying) stopAll(false); }, [minutes]);

    // Load info + image
    useEffect(()=>{
      let alive=true;
      const load = async ()=>{
        if (!site) return;
        try{
          setLoading(true); setError(""); setImgBroken(false);
          const [iRes, pRes] = await Promise.all([ fetch(ENDPOINTS.siteInfo(site)), fetch(ENDPOINTS.siteImage(site)) ]);
          const iRaw = await safeJSON(iRes);
          const pRaw = await safeJSON(pRes);
          if (!alive) return;
          setInfo(normalizeInfo(iRaw));
          const url = normalizeImage(pRaw) || "";
          setImg(url);
        } catch(e){ console.error(e); if (!alive) return; setInfo(null); setImg(""); setImgBroken(true); }
        finally{ if (alive) setLoading(false); }
      };
      load();
      return ()=>{ alive=false; };
    }, [site]);

    // Visibility-driven quality switch
    useEffect(()=>{
      const onVis = () => {
        const eg = irRef.current;
        if (!eg) return;
        eg.enterLowPower(document.visibilityState !== "visible");
        try { eg.context && eg.context.resume(); } catch {}
      };
      document.addEventListener("visibilitychange", onVis);
      return ()=>document.removeEventListener("visibilitychange", onVis);
    }, []);

    function stopAll(collapse=false){
      if (irRef.current){ irRef.current.stop(); irRef.current = null; }
      setIsPlaying(false);
      if (collapse){ setPlayerOpen(false); setCurrentTime(0); }
    }

    function tick(){
      const eg = irRef.current; if (!eg || !eg.context) return;
      const t = Math.max(0, eg.context.currentTime - eg.startedAt);
      if (t >= totalTime){
        if (eg.loop){ eg.startedAt = eg.context.currentTime; setCurrentTime(0); return; }
        pause();
        return;
      }
      setCurrentTime(t);
    }

    async function play(sendStop=true){
      if (!site) return;
      if (sendStop) stopOtherAppAudio();
      setPlayerOpen(true); setError("");

      try{
        setLoading(true);

        if (irRef.current) { irRef.current.stop(); irRef.current = null; }
        irRef.current = new IREngine();
        const eg = irRef.current;

        // Ensure context and immediately start the iOS background pipe within this gesture
        await eg.ensure();
        await eg.attachPipe();

        eg.loop = loop; 
        eg.setVolume(volume); 
        eg.onUpdate = tick;

        const resp = await fetch(ENDPOINTS.genIR, {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({ site, minutes })
        });
        const json = await safeJSON(resp);

        const hints = {
          base_hz: json?.base_hz ?? json?.carrier_hz ?? json?.program?.base_hz,
          binaural_split_hz: json?.binaural_split_hz ?? json?.program?.binaural_split_hz,
          isotonic_rate_hz: json?.isotonic_rate_hz ?? json?.program?.isotonic_rate_hz,
          pink_noise_gain: json?.source_noise_gain ?? json?.program?.pink_noise_gain
        };

        await eg.loadAndStart(json || {}, hints);
        eg.startedAt = eg.context.currentTime;
        setIsPlaying(true);

        if ("mediaSession" in navigator) {
          navigator.mediaSession.metadata = new MediaMetadata({
            title: site || "Sanctra IR",
            artist: "PeMFHealing.app",
            artwork: img ? [{ src: img, sizes: "512x512", type: "image/jpeg" }] : []
          });
          navigator.mediaSession.setActionHandler("play", () => play(false));
          navigator.mediaSession.setActionHandler("pause", () => pause(false));
          navigator.mediaSession.setActionHandler("stop", () => pause(true));
        }
      } catch(e){ console.error(e); setError("IR synthesis failed."); }
      finally{ setLoading(false); }
    }

    function pause(collapse=false){ stopAll(collapse); }
    function seek(v){
      const t = Number(v);
      if (!isFinite(t) || !irRef.current) return;
      const eg = irRef.current, ctx = eg.context;
      eg.startedAt = ctx.currentTime - Math.min(totalTime, Math.max(0, t));
      setCurrentTime(t);
    }
    function setLooping(){
      setLoop(v => { const n = !v; if (irRef.current) irRef.current.loop = n; return n; });
    }
    function setVol(v){
      const val = Number(v); setVolume(val); if (irRef.current) irRef.current.setVolume(val);
    }

    const minuteOptions = [15, 36, 45];

    return (
      React.createElement(React.Fragment, null,

        booting && React.createElement("div", { className:"boot" },
          React.createElement("div", { className:"bootInner" },
            React.createElement("div", { className:"spinner big" }),
            React.createElement("div", { className:"bootText" }, "Loading sanctra presets…")
          )
        ),

        React.createElement("main", { className:"container" },

          React.createElement("div", { className:"dropdowns" },
            React.createElement(Dropdown, { value:country, options:countries, onChange:setCountry, busy:loading && !countries.length }),
            React.createElement(Dropdown, { value:site, options:sites, onChange:setSite, busy:loading && !sites.length })
          ),

          React.createElement("div", { className:"card" },
            React.createElement("div", { className:"hero" },
              img && !imgBroken
                ? React.createElement("img", { src:img, alt:site, crossOrigin:"anonymous", referrerPolicy:"no-referrer", onError:()=>setImgBroken(true) })
                : React.createElement("div", { className:"loading" }, React.createElement("div", { className:"spinner"}), "Image unavailable"),
              React.createElement("button", {
                className:"mediaOverlay " + (isPlaying ? "pause" : "play"),
                onClick: isPlaying ? ()=>pause(false) : ()=>play(true),
                title: isPlaying ? "Pause" : "Play",
                "aria-label": isPlaying ? "Pause" : "Play"
              }, React.createElement("span", { className:"glyph" }))
            ),

            React.createElement("div", { className:"controlsRow" },
              React.createElement("div", { className:"seg" },
                minuteOptions.map(min =>
                  React.createElement("button", {
                    key:min, className:"pill "+(minutes===min?"active":""), onClick:()=>{ if(!isPlaying) setMinutes(min); }
                  }, `${min} min`)
                )
              ),
              loading ? React.createElement("div", { className:"loading small" }, React.createElement("div",{className:"spinner"}),"Fetching…") : null
            ),

            React.createElement("div", { className:"section" },
              React.createElement("h3", null, "Country"),
              React.createElement("p", null, country || "")
            ),

            React.createElement("div", { className:"section" },
              React.createElement("h3", null, "Site Information"),
              info ? React.createElement("p", null, info?.description || "-")
                   : React.createElement("p", { className:"muted" }, "Loading…")
            ),

            info && info.why_sacred && React.createElement("div", { className:"section" },
              React.createElement("h3", null, "Why Sacred"),
              React.createElement("p", null, info.why_sacred)
            ),

            React.createElement("div", { className:"section" },
              React.createElement("h3", null, "Site Benefits"),
              info ? React.createElement("p", null, info?.health_benefits || "-")
                   : React.createElement("p", { className:"muted" }, "Loading…")
            ),

            info && info.who_is_this_for && React.createElement("div", { className:"section" },
              React.createElement("h3", null, "Who is this for"),
              React.createElement("p", null, info.who_is_this_for)
            ),

            React.createElement("div", { className:"section" },
              React.createElement("p", { className:"fineprint" },
                "Disclaimer: For education only. Not medical advice. Consult a qualified professional."
              )
            ),

            error && React.createElement("div", { className:"section" }, React.createElement("div", { className:"error" }, error))
          ),

          React.createElement("footer", { className:"footer" }, "Copyright® 2025 PeMFHealing.app")
        ),

        React.createElement("div", { className:"player " + (playerOpen ? "open":"") },
          React.createElement("div", { className:"playerInner" },
            React.createElement("div", { className:"playerRow" },
              React.createElement("img", { className:"thumb", src:img || "", alt:"" }),
              React.createElement("div", { className:"title" }, `Country: ${country || "-"} · Site: ${site || "-"}`)
            ),
            React.createElement("div", { className:"playerCtrls" },
              React.createElement("button", { className:"iconBtn", onClick: isPlaying ? ()=>pause(false) : ()=>play(true), title: isPlaying ? "Pause":"Play" }, isPlaying ? "❚❚" : "▶"),
              React.createElement("button", { className:"iconBtn " + (loop?"active":""), onClick:setLooping, title:"Loop" }, "∞"),
              React.createElement("input", { className:"vol", type:"range", min:"0", max:"1", step:"0.01", value:volume, onChange:e=>setVol(e.target.value), title:"Volume", "aria-label":"Volume" }),
              React.createElement("div", { className:"pushRight" }),
              React.createElement("button", { className:"iconBtn closeBtn", onClick:()=>setPlayerOpen(false), title:"Close" }, "✕")
            ),
            React.createElement("div", { className:"bar" },
              React.createElement("input", { className:"progress", type:"range", min:"0", max:String(totalTime), step:"1", value:String(Math.min(currentTime,totalTime)), onChange:e=>seek(e.target.value) }),
              React.createElement("div", { className:"timeRow" },
                React.createElement("div", null, fmtTime(currentTime)),
                React.createElement("div", null, fmtTime(totalTime))
              )
            )
          )
        )
      )
    );
  }

  ReactDOM.createRoot(document.getElementById("root")).render(React.createElement(App));
  </script>
</body>
</html>
